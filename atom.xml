<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://iamywang.github.io/atom.xml" rel="self"/>
  
  <link href="https://iamywang.github.io/"/>
  <updated>2023-07-18T11:30:00.000Z</updated>
  <id>https://iamywang.github.io/</id>
  
  <author>
    <name>iamywang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023、盛夏、约会</title>
    <link href="https://iamywang.github.io/2023/07/18/dating-2307/"/>
    <id>https://iamywang.github.io/2023/07/18/dating-2307/</id>
    <published>2023-07-18T11:30:00.000Z</published>
    <updated>2023-07-18T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>旅途：从WUHAN到JINAN</p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/1.jpg"                      alt="1"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/2.jpg"                      alt="2"                ></p><p>美食：豆腐脑、油条、胡辣汤</p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/3.jpg"                      alt="3"                ></p><p>美食：奶茶、烤鱼、包子</p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/4.jpg"                      alt="4"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/5.jpg"                      alt="5"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/6.jpg"                      alt="6"                ></p><p>美食：铁锅炖、鮰鱼、排骨</p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/7.jpg"                      alt="7"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/8.jpg"                      alt="8"                ></p><p>晚霞：登山、夕阳</p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/9.jpg"                      alt="9"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/10.jpg"                      alt="10"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2307/11.jpg"                      alt="11"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;旅途：从WUHAN到JINAN&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     alt=&quot;image&quot;
                     data-src=&quot;/images/datin</summary>
      
    
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="2023" scheme="https://iamywang.github.io/tags/2023/"/>
    
    <category term="约会" scheme="https://iamywang.github.io/tags/%E7%BA%A6%E4%BC%9A/"/>
    
    <category term="盛夏" scheme="https://iamywang.github.io/tags/%E7%9B%9B%E5%A4%8F/"/>
    
  </entry>
  
  <entry>
    <title>道阻且长——谨以此文纪念自己的第一篇学术论文</title>
    <link href="https://iamywang.github.io/2023/07/13/first-paper/"/>
    <id>https://iamywang.github.io/2023/07/13/first-paper/</id>
    <published>2023-07-13T15:15:00.000Z</published>
    <updated>2023-07-13T15:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2023年7月13日晚上，历时一年之余，经历拒稿-&gt;拒稿-&gt;大修-&gt;大修-&gt;小修的洗礼，终于拿到第一篇学术论文的录用通知。在此，我想将自己的经历记录下来，以此勉励自己。同时，我也非常感谢对我的论文提供帮助的两位老师、六次审稿过程中所有的匿名审稿人、还有一直给予我精神支撑的我的女朋友。</p><h2 id="兴奋：想法的产生"><a href="#兴奋：想法的产生" class="headerlink" title="兴奋：想法的产生"></a>兴奋：想法的产生</h2><p>2021年9月，踏上了从我的家乡山东到武汉的飞机，开始了研究生生涯的旅程。尽管自己对于科研生活充满了期待与梦想，但由于自己迟迟无法找到很合适的研究点，因此在研究生的第一年，自己一直处于迷茫的状态。<br>一个偶然的契机，在阅读了大量的与侧信道有关的论文之后，终于发现了一个可以在智能手机上利用侧信道攻击的点。然后，经过了几个星期的实验与分析，终于确定了自己的想法是可行的，并决定将其写成论文。</p><h2 id="历练：英文论文撰写"><a href="#历练：英文论文撰写" class="headerlink" title="历练：英文论文撰写"></a>历练：英文论文撰写</h2><p>由于自己的想法是在智能手机上利用侧信道漏洞发起攻击，因此也很感谢自己的导师出资购买了两块用于实验的手机。正是因为有了如此多的设备，才能够帮助我完成跨设备的实验以及真实场景下的实验，使得这个工作的工作量更加充足、更具有合理性。<br>经过了接近两个月的实验方法设计、实验数据采集与实验结果分析后，我得到了非常不错的实验结果。然后在2022年的6月，自己终于开始撰写这篇期待已久的科研论文。<br>在论文撰写的过程中，由于自己的英文水平不是特别出色（彼时英语六级的分数只有450多分，不过随着自己阅读与写作水平的提升，现在已经能够考到550多分了，我已经非常满意），在写作的过程中是采用中文翻译英文的办法（主要借助的工具是DeepL）以及自己再调整措辞和语序的方式。最后，在7月份，我的论文也完成了，并准备投稿到一个CCF-A类的期刊上。</p><h2 id="坦然：第一次投稿到拒绝"><a href="#坦然：第一次投稿到拒绝" class="headerlink" title="坦然：第一次投稿到拒绝"></a>坦然：第一次投稿到拒绝</h2><p>第一次投稿的时间是2022年的7月10日，在2022年9月14日收到了拒稿的邮件。三位审稿人一位给出了大修，一位给出了重投，还有一位是拒绝。尽管这篇文章被拒绝了，但是三位审稿人以及编辑都非常认可我的创新点，因此我仍然对这篇文章充满希望。</p><p><img                       lazyload                     alt="image"                     data-src="/images/first-paper/1.png"                      alt="1"                ></p><p>然后，我按照三位审稿人给出的意见，逐条逐点进行修改，包括阐述原来论文中表述不够清晰的地方、增加很多很多的实验（约50%）、去掉原来没有必要出现的代码段等等。最后，这篇文章的篇幅也从原来的12页扩展到了15页。我仍然充满期待，因此选择再冲一次CCF-A类期刊。</p><h2 id="不甘：第二次投稿到拒绝"><a href="#不甘：第二次投稿到拒绝" class="headerlink" title="不甘：第二次投稿到拒绝"></a>不甘：第二次投稿到拒绝</h2><p>经过了接近一个月的补充实验和修改，我在2022年10月4日再次投稿到另一个期刊。然而，不遂人愿，2023年3月2日，再次收到拒稿邮件。这次只有两位审稿人，一位给出了大修，一位给出了拒绝，编辑的评论是这篇文章的质量达不到期刊的要求。此时，一是感觉有些难受，二是有些遗憾，总感觉这次的版本投稿到第一次的期刊上就更有机会。不过，我还是相信这篇文章总会有它的归宿，因此我仍然按照审稿人的意见，详细修改了文章。</p><p><img                       lazyload                     alt="image"                     data-src="/images/first-paper/2.png"                      alt="2"                ></p><h2 id="激动：第三次投稿到大修"><a href="#激动：第三次投稿到大修" class="headerlink" title="激动：第三次投稿到大修"></a>激动：第三次投稿到大修</h2><p>修改完成后，3月7日，我选择投稿到一个SCI一区的期刊上，非常开心能够在4月21日收到大修的邮件。虽然邮件中看不出三位审稿人具体的推荐意见，不过三位审稿人都非常认可我的工作，提出的14条意见要么是文章结构、要么是对比分析、要么是一些开放性的问题，因此我当时非常的激动。接下来的工作就是逐条回复审稿人，撰写response。</p><p><img                       lazyload                     alt="image"                     data-src="/images/first-paper/3.png"                      alt="3"                ></p><h2 id="紧张：返修到又一次大修"><a href="#紧张：返修到又一次大修" class="headerlink" title="紧张：返修到又一次大修"></a>紧张：返修到又一次大修</h2><p>在修改完成后，5月13日我提交了返修稿和回信，这次审稿人也是出奇地快，仅仅4天后的5月17日，就给了又一次大修。这次审稿人只有两个，其中一个同意接收，另一个给出了大修。审稿人的主要意见是觉得我的文章逻辑不够清晰、图片的表述不够清晰、摘要和引言的逻辑不太好、参考文献太旧等。这次我仍然非常细心谨慎回复审稿人的每个问题，尽管有一个问题并不好解答和修改，我也有理有据地回复审稿人我没有修改以及为什么没有修改。</p><p><img                       lazyload                     alt="image"                     data-src="/images/first-paper/4.png"                      alt="4"                ></p><h2 id="还是紧张：返修到小修"><a href="#还是紧张：返修到小修" class="headerlink" title="还是紧张：返修到小修"></a>还是紧张：返修到小修</h2><p>这次的大修在6月11日结束，并提交了返修稿和回信。经过了15天的等待，6月26日，我收到了小修的邮件。这次审稿人仍然有两个，一个接收，一个小修。审稿人现在已经认可我这篇文章的质量能够发表在这个期刊上，然后提出了四点小意见，包括修改摘要和引言的措辞、突出我在文中给出的建议、图表的数据格式、将两个章节合并等。这次的修改非常迅速，我同样认真斟酌修改，并恳切地回复每条建议。</p><p><img                       lazyload                     alt="image"                     data-src="/images/first-paper/5.png"                      alt="5"                ></p><h2 id="尘埃落定：小修到接收"><a href="#尘埃落定：小修到接收" class="headerlink" title="尘埃落定：小修到接收"></a>尘埃落定：小修到接收</h2><p>在修改完成后，我于7月12日提交了返修稿。第二天（即7月13日），我的文章被期刊接收了，这也是我学术生涯的第一个小小的里程碑。虽然发表一篇SCI一区的论文在计算机领域不是特别突出的成就，因为我的工作实在是没有办法发表在顶刊和顶会上，但这对于我来说只是一个起点，我也希望自己以后能够发表高水平和高质量的论文。</p><p><img                       lazyload                     alt="image"                     data-src="/images/first-paper/6.png"                      alt="6"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/first-paper/7.png"                      alt="7"                ></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>科研不易，冷暖自知。</p><p>在收到小修意见时，有一位审稿人提出了一个非常关键的问题，让我产生了深深的思考：</p><blockquote><p>The current tone of this manuscript sounds like that the authors are educating attackers a new approach to stealth user privacy, which I believe is not the true purpose of this paper. The purpose of this paper is meant to demonstrate a possible attack on an overlooked security vulnerability, which could become very powerful if attackers use sophisticated techniques.</p></blockquote><p>对啊，我们所有做安全的人，我们进行漏洞挖掘的目的是什么？难道我们是为了破坏计算机、破坏移动设备的隐私数据吗？难道我们是要帮助攻击者来入侵其他用户吗？仔细想来，我们的目的应该是让大家注意到这个问题，从而避免问题、加以防护、或者进行检测，这才应该是我们的出发点。</p><p>此外，偶然在知乎上读到如下回答，深有同感：</p><blockquote><p>The academic is not an army race. It does not really matter how fancy the model is. It does not really matter whether the model can achieve the sota performance. The real innovation is to find something new and this work has found a fresh new perspective.</p></blockquote><p>我们为什么一定要比别人好呢？似乎我的工作也并不是比别人好，也达不到Related Work中的performance，那又如何呢？如果我们能找到一个别人没有关注过的点，哪怕很微小，似乎只要有一点点novelty，足矣。相反，我也在深思，对于已知的威胁点，通过ML、DL、甚至是RL的方式提高攻击者攻击能力的意义在哪里呢，毕竟这些威胁已经被证明存在了，除非目前的防御手段无法防御…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2023年7月13日晚上，历时一年之余，经历拒稿-&amp;gt;拒稿-&amp;gt;大修-&amp;gt;大修-&amp;gt;小修的洗礼，终于拿到第一篇学术论文的录用</summary>
      
    
    
    
    <category term="科研" scheme="https://iamywang.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
    <category term="科研" scheme="https://iamywang.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
    <category term="论文" scheme="https://iamywang.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>2023、故乡、足球</title>
    <link href="https://iamywang.github.io/2023/06/04/football-23/"/>
    <id>https://iamywang.github.io/2023/06/04/football-23/</id>
    <published>2023-06-04T12:00:00.000Z</published>
    <updated>2023-06-04T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     alt="image"                     data-src="/images/football-23/4.jpg"                      alt="足球4"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/football-23/1.jpg"                      alt="足球1"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/football-23/3.jpg"                      alt="足球3"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/football-23/2.jpg"                      alt="足球2"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     alt=&quot;image&quot;
                     data-src=&quot;/images/football-23/4.jpg&quot;
         </summary>
      
    
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="2023" scheme="https://iamywang.github.io/tags/2023/"/>
    
    <category term="足球" scheme="https://iamywang.github.io/tags/%E8%B6%B3%E7%90%83/"/>
    
  </entry>
  
  <entry>
    <title>2023、五一错峰、约会</title>
    <link href="https://iamywang.github.io/2023/05/08/dating-2/"/>
    <id>https://iamywang.github.io/2023/05/08/dating-2/</id>
    <published>2023-05-08T12:55:00.000Z</published>
    <updated>2023-05-08T12:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/1.jpg"                      alt="约会1"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/2.jpg"                      alt="约会2"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/3.jpg"                      alt="约会3"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/4.jpg"                      alt="约会4"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/5.jpg"                      alt="约会5"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/6.jpg"                      alt="约会6"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/7.jpg"                      alt="约会7"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/8.jpg"                      alt="约会8"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-2/9.jpg"                      alt="约会9"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     alt=&quot;image&quot;
                     data-src=&quot;/images/dating-2/1.jpg&quot;
            </summary>
      
    
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="2023" scheme="https://iamywang.github.io/tags/2023/"/>
    
    <category term="五一" scheme="https://iamywang.github.io/tags/%E4%BA%94%E4%B8%80/"/>
    
    <category term="约会" scheme="https://iamywang.github.io/tags/%E7%BA%A6%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>ROP/JOP/COP（1）——攻击基本原理、现有芯片级对策</title>
    <link href="https://iamywang.github.io/2023/03/23/rop-1/"/>
    <id>https://iamywang.github.io/2023/03/23/rop-1/</id>
    <published>2023-03-23T02:00:00.000Z</published>
    <updated>2023-03-23T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从计算机体系结构的角度来说，内存安全违规（memory safety violation）一般分为两大类：</p><ul><li>时间违规（temporal violation）：典型代表为Use-After-Free（UAF）漏洞，即在释放内存后，再次对该内存进行访问。</li><li>空间违规（spatial violation）：典型代表为栈溢出（stack overflow）漏洞，即在栈上分配的内存空间不足以存放当前的数据。</li></ul><p>而面向返回编程（Return-Oriented Programming，ROP）、面向跳转编程（Jump-Oriented Programming，JOP）和面向调用编程（Call-Oriented Programming，COP）都是基于空间违规的攻击手段，本文将从攻击基本原理、现有芯片级对策和思考三个方面来介绍ROP&#x2F;JOP&#x2F;COP。</p><p>而ROP攻击产生的一大原因是因为，现代操作系统为了防止攻击者在栈上发起代码注入漏洞，采用了W^X的内存保护机制，即栈上的内存空间只能执行，不能写入。因此，攻击者在栈上发起代码注入漏洞时，只能通过覆盖返回地址来控制程序的执行流程，而这种攻击手段就是ROP。</p><p><img                       lazyload                     alt="image"                     data-src="/images/rop-1/1.png"                      alt="ROP"                ></p><p>以下是一个较为详细的ppt：<a href="https://iamywang.github.io/images/rop-1/memory-safety.pdf">memory-safety.pdf</a></p><h2 id="ROP-x2F-JOP-x2F-COP"><a href="#ROP-x2F-JOP-x2F-COP" class="headerlink" title="ROP&#x2F;JOP&#x2F;COP"></a>ROP&#x2F;JOP&#x2F;COP</h2><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>在x86中，ret指令指令的执行可以看做：<br>（1）pop：从栈中弹出一个返回地址；<br>（2）jmp：跳转到该返回地址处执行。</p><p>此外，函数调用的参数传递是通过寄存器（eax、ebx、ecx、edx等）来完成的，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>其中，系统中断的值为0x80，而execve调用的值为0xb（存放在eax寄存器中），剩余三个参数分别为：&#x2F;bin&#x2F;sh（存放在ebx寄存器中）、NULL（存放在ecx寄存器中）、NULL（存放在edx寄存器中）。因此，如果攻击者能够将返回地址覆盖为0x80指令所在的地址，并且将四个寄存器的值分别设置为0xb、&#x2F;bin&#x2F;sh、NULL、NULL，那么就可以实现execve(“&#x2F;bin&#x2F;sh”, NULL, NULL)的调用。ROP代码段是一串以ret指令结尾的代码段，因此攻击者希望填充的恶意数据为：<br>（0）数据与返回地址的偏移量；<br>（1）<code>pop eax; ret;</code>所在的地址；<br>（2）eax寄存器的目标值0xb；<br>（3）<code>pop ebx; ret;</code>所在的地址；<br>（4）ebx寄存器的目标值&#x2F;bin&#x2F;sh；<br>（5）<code>pop ecx; ret;</code>所在的地址；<br>（6）ecx寄存器的目标值NULL；<br>（7）<code>pop edx; ret;</code>所在的地址；<br>（8）edx寄存器的目标值NULL；<br>（9）0x80指令所在的地址。</p><p>指令序列的寻找可以通过JonathanSalwan开发的ROPgadget工具[1]来完成，以下面这段代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">gets(&amp;var1);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>由于gets函数存在栈溢出漏洞，因此攻击者可以通过恶意输入var1覆盖返回地址，并完成恶意代码执行：<br>（1）计算var1与返回地址的偏移量；<br>（2）用ROPgadget工具生成ROP链；<br>（3）将ROP链写入var1，从而控制程序的执行流程。</p><h3 id="JOP-x2F-COP"><a href="#JOP-x2F-COP" class="headerlink" title="JOP&#x2F;COP"></a>JOP&#x2F;COP</h3><p>在JOP攻击中，攻击者控制的恶意数据覆盖jmp指令的跳转地址实现控制流劫持，JOP代码段是一串以jmp指令结尾的代码段。而在COP攻击中，攻击者控制的恶意数据覆盖call指令的跳转地址实现控制流劫持，COP代码段是一串以call指令结尾的代码段。对于JOP&#x2F;COP攻击而言，攻击者要找寻的代码段中，除了要修改目标寄存器外，还要包含一个用于修改后续jmp&#x2F;call跳转地址的pop指令（在ROP攻击中，由ret指令的特点，不需要攻击者额外控制）。</p><p>值得一提的是，在实际应用中，攻击者为了达成劫持控制流的目的，会将三种代码段通过组合的方式发起混合攻击。</p><h2 id="现有硬件级对策"><a href="#现有硬件级对策" class="headerlink" title="现有硬件级对策"></a>现有硬件级对策</h2><h3 id="Intel-CET"><a href="#Intel-CET" class="headerlink" title="Intel CET"></a>Intel CET</h3><p>Intel CET（Control-Flow Enforcement Technology）是Intel新推出的一项新的硬件级对策，其主要目的是防止攻击者通过ROP&#x2F;JOP&#x2F;COP等攻击手段来劫持控制流。<br>对于ROP攻击的防护，其基本思想与影子栈（shadow stack）类似，即由操作系统在内存中复制一份程序的内存栈或者是仅仅保留控制流跳转地址。然后，这个影子栈无法由正常的store、load指令进行控制，只能通过专门的指令来进行控制。因此，即使攻击者覆盖了软件栈上的返回地址，但是由于影子栈中仍然保存着原始的跳转地址，因此检查失败后会通过抛出异常来终止程序的执行。<br>对于JOP&#x2F;COP攻击的防护，Intel提出一种叫做IBT（Indirect Branch Tracking）的技术，其基本思想是通过编译器在合理的间接跳转中⽤新的指令做标记，然后程序执行时会检查下一条指令是否为新添加的指令（endbr），如果不是则会抛出#CP异常。</p><h3 id="ARM-PAC"><a href="#ARM-PAC" class="headerlink" title="ARM PAC"></a>ARM PAC</h3><p>ARM PAC（Pointer Authentication）是ARMv8.3引入的一项新的硬件级对策，其主要通过对指针进行鉴权来防止攻击者通过ROP&#x2F;JOP&#x2F;COP等攻击手段来劫持控制流。<br>这种防护方法的基本原理是，利用64位地址空间中暂时空闲的高16位来存放指针的鉴权结果（MAC码），然后在每次指针使用前，都会对指针进行鉴权，如果鉴权失败，则会抛出异常来终止程序的执行。</p><h2 id="相关论文（体系结构级别）"><a href="#相关论文（体系结构级别）" class="headerlink" title="相关论文（体系结构级别）"></a>相关论文（体系结构级别）</h2><h3 id="论文：PACMAN（ISCA-2022）"><a href="#论文：PACMAN（ISCA-2022）" class="headerlink" title="论文：PACMAN（ISCA 2022）"></a>论文：PACMAN（ISCA 2022）</h3><p>利用预测执行机制，通过隐蔽信道泄漏PAC机制的鉴权结果。</p><p><img                       lazyload                     alt="image"                     data-src="/images/rop-1/2.png"                      alt="PACMAN"                ></p><h3 id="论文：ZeRO（ISCA-2021）"><a href="#论文：ZeRO（ISCA-2021）" class="headerlink" title="论文：ZeRØ（ISCA 2021）"></a>论文：ZeRØ（ISCA 2021）</h3><p>ZeRØ提出了独特的内存指令和新颖的元数据编码方案来保护代码和数据指针，仅仅只需要微小的微架构变化。ZeRØ在SPEC CPU2017基准上的性能开销为零，VLSI测量显示了低功率和面积开销。</p><p><img                       lazyload                     alt="image"                     data-src="/images/rop-1/3.png"                      alt="ZeRØ"                ></p><h3 id="论文：No-FAT（ISCA-2021）"><a href="#论文：No-FAT（ISCA-2021）" class="headerlink" title="论文：No-FAT（ISCA 2021）"></a>论文：No-FAT（ISCA 2021）</h3><p>No-FAT将内存分配大小（例如malloc大小）作为一个架构特征，来克服传统内存安全方法的许多棘手问题，例如与不安全软件的兼容性和显著的性能下降。No-FAT在SPEC CPU2017基准测试中产生了8%的开销，VLSI测量显示了低功率和面积开销。</p><p><img                       lazyload                     alt="image"                     data-src="/images/rop-1/4.png"                      alt="No-FAT"                ></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a class="link"   href="https://github.com/JonathanSalwan/ROPgadget" >https://github.com/JonathanSalwan/ROPgadget<i class="fas fa-external-link-alt"></i></a></p><p>[2] Ravichandran, J., Na, W. T., Lang, J., &amp; Yan, M. (2022, June). PACMAN: attacking ARM pointer authentication with speculative execution. In Proceedings of the 49th Annual International Symposium on Computer Architecture (pp. 685-698).</p><p>[3] Ziad, M. T. I., Arroyo, M. A., Manzhosov, E., &amp; Sethumadhavan, S. (2021, June). ZeRØ: Zero-overhead resilient operation under pointer integrity attacks. In 2021 ACM&#x2F;IEEE 48th Annual International Symposium on Computer Architecture (ISCA) (pp. 999-1012). IEEE.</p><p>[4] Ziad, M. T. I., Arroyo, M. A., Manzhosov, E., Piersma, R., &amp; Sethumadhavan, S. (2021, June). No-FAT: Architectural support for low overhead memory safety checks. In 2021 ACM&#x2F;IEEE 48th Annual International Symposium on Computer Architecture (ISCA) (pp. 916-929). IEEE.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从计算机体系结构的角度来说，内存安全违规（memory safety violation）一般分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间违</summary>
      
    
    
    
    <category term="内存安全" scheme="https://iamywang.github.io/categories/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="内存安全" scheme="https://iamywang.github.io/tags/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8/"/>
    
    <category term="栈溢出" scheme="https://iamywang.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="面向返回编程" scheme="https://iamywang.github.io/tags/%E9%9D%A2%E5%90%91%E8%BF%94%E5%9B%9E%E7%BC%96%E7%A8%8B/"/>
    
    <category term="面向跳转编程" scheme="https://iamywang.github.io/tags/%E9%9D%A2%E5%90%91%E8%B7%B3%E8%BD%AC%E7%BC%96%E7%A8%8B/"/>
    
    <category term="面向调用编程" scheme="https://iamywang.github.io/tags/%E9%9D%A2%E5%90%91%E8%B0%83%E7%94%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2022、国庆节、约会</title>
    <link href="https://iamywang.github.io/2022/10/02/dating-1/"/>
    <id>https://iamywang.github.io/2022/10/02/dating-1/</id>
    <published>2022-10-02T14:45:00.000Z</published>
    <updated>2022-10-02T14:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     alt="image"                     data-src="/images/dating-1/1.jpg"                      alt="约会1"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-1/2.jpg"                      alt="约会2"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-1/3.jpg"                      alt="约会3"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-1/4.jpg"                      alt="约会4"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-1/5.jpg"                      alt="约会5"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-1/6.jpg"                      alt="约会6"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/dating-1/7.jpg"                      alt="约会7"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     alt=&quot;image&quot;
                     data-src=&quot;/images/dating-1/1.jpg&quot;
            </summary>
      
    
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="约会" scheme="https://iamywang.github.io/tags/%E7%BA%A6%E4%BC%9A/"/>
    
    <category term="2022" scheme="https://iamywang.github.io/tags/2022/"/>
    
    <category term="国庆" scheme="https://iamywang.github.io/tags/%E5%9B%BD%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>gem5（5）——扩展gem5功能初探并实现简单的MemoryObject</title>
    <link href="https://iamywang.github.io/2022/09/13/gem5-5/"/>
    <id>https://iamywang.github.io/2022/09/13/gem5-5/</id>
    <published>2022-09-13T02:55:00.000Z</published>
    <updated>2022-09-13T02:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>参考learning gem5的part II部分进行gem5的学习。</p><p>主要工作：</p><ul><li>自定义实现了一个简单的SimpleObject，并将其成功在gem5中执行；</li><li>将SimpleObject扩展为MemoryObject，并将其分别与CPU的i-cache&#x2F;d-cache端口和内存总线相连；</li><li>输出MemoryObject对应的配置图，并成功模拟执行。</li></ul><h2 id="SimpleObject"><a href="#SimpleObject" class="headerlink" title="SimpleObject"></a>SimpleObject</h2><h3 id="创建python类SimpleObject"><a href="#创建python类SimpleObject" class="headerlink" title="创建python类SimpleObject"></a>创建python类SimpleObject</h3><p>首先创建一个python类，包含三个参数：</p><ul><li>type：类名</li><li>cxx_header：对应的C++头文件</li><li>cxx_class：对应的C++类名</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObject</span>(<span class="title class_ inherited__">SimObject</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;SimpleObject&#x27;</span></span><br><span class="line">    cxx_header = <span class="string">&quot;learning_gem5/part2/simple_object.hh&quot;</span></span><br><span class="line">    cxx_class = <span class="string">&#x27;gem5::SimpleObject&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="创建C-类SimpleObject"><a href="#创建C-类SimpleObject" class="headerlink" title="创建C++类SimpleObject"></a>创建C++类SimpleObject</h3><p>然后创建与python类对应的C++类，并创建简单的hello函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObject</span> : <span class="keyword">public</span> SimObject</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SimpleObject</span>(<span class="type">const</span> SimpleObjectParams &amp;p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SimpleObject::<span class="built_in">SimpleObject</span>(<span class="type">const</span> SimpleObjectParams &amp;params) :</span><br><span class="line">    <span class="built_in">SimObject</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World! From a SimObject!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册SimpleObject"><a href="#注册SimpleObject" class="headerlink" title="注册SimpleObject"></a>注册SimpleObject</h3><p>修改SConscript文件，将先前创建的python类和C++类添加进去：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimObject(<span class="string">&#x27;SimpleObject.py&#x27;</span>, sim_objects=[<span class="string">&#x27;SimpleObject&#x27;</span>])</span><br><span class="line">Source(<span class="string">&#x27;simple_object.cc&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="重新编译gem5"><a href="#重新编译gem5" class="headerlink" title="重新编译gem5"></a>重新编译gem5</h3><p>执行scons重新编译gem5：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scons build/X86/gem5.opt -j5</span><br></pre></td></tr></table></figure><h3 id="配置并运行"><a href="#配置并运行" class="headerlink" title="配置并运行"></a>配置并运行</h3><p>修改自定义的配置文件，设置root.hello为SimpleObject()，并执行：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-5/1.png"                      alt="运行结果1"                ></p><p>根据执行结果的输出，可以看到成功的添加SimpleObject并运行。</p><h2 id="MemoryObject"><a href="#MemoryObject" class="headerlink" title="MemoryObject"></a>MemoryObject</h2><h3 id="创建基类"><a href="#创建基类" class="headerlink" title="创建基类"></a>创建基类</h3><p>创建python类和C++类，假设MemoryObject一端连接CPU一端连接内存总线，那么需要创建三个接口：</p><ul><li>CPU的i-cache；</li><li>CPU的d-cache；</li><li>内存总线。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMemobj</span>(<span class="title class_ inherited__">SimObject</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;SimpleMemobj&#x27;</span></span><br><span class="line">    cxx_header = <span class="string">&quot;learning_gem5/part2/simple_memobj.hh&quot;</span></span><br><span class="line">    cxx_class = <span class="string">&#x27;gem5::SimpleMemobj&#x27;</span></span><br><span class="line"></span><br><span class="line">    inst_port = ResponsePort(<span class="string">&quot;CPU side port, receives requests&quot;</span>)</span><br><span class="line">    data_port = ResponsePort(<span class="string">&quot;CPU side port, receives requests&quot;</span>)</span><br><span class="line">    mem_side = RequestPort(<span class="string">&quot;Memory side port, sends requests&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SimpleMemobj::<span class="built_in">SimpleMemobj</span>(<span class="type">const</span> SimpleMemobjParams &amp;params) :</span><br><span class="line">    <span class="built_in">SimObject</span>(params),</span><br><span class="line">    <span class="built_in">instPort</span>(params.name + <span class="string">&quot;.inst_port&quot;</span>, <span class="keyword">this</span>),</span><br><span class="line">    <span class="built_in">dataPort</span>(params.name + <span class="string">&quot;.data_port&quot;</span>, <span class="keyword">this</span>),</span><br><span class="line">    <span class="built_in">memPort</span>(params.name + <span class="string">&quot;.mem_side&quot;</span>, <span class="keyword">this</span>),</span><br><span class="line">    <span class="built_in">blocked</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>根据learning gem5网站的描述以及提供的开源代码，大致分为以下15个函数：</p><table><thead><tr><th align="center">序号</th><th align="center">作用域</th><th align="left">函数</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SimpleMemobj</td><td align="left">SimpleMemobj(const SimpleMemobjParams &amp;params)</td></tr><tr><td align="center">2</td><td align="center">SimpleMemobj</td><td align="left">Port&amp; getPort(const std::string &amp;if_name, PortID idx)</td></tr><tr><td align="center">3</td><td align="center">SimpleMemobj::CPUSidePort</td><td align="left">void sendPacket(PacketPtr pkt)</td></tr><tr><td align="center">4</td><td align="center">SimpleMemobj::CPUSidePort</td><td align="left">AddrRangeList getAddrRanges() const</td></tr><tr><td align="center">5</td><td align="center">SimpleMemobj::CPUSidePort</td><td align="left">void trySendRetry()</td></tr><tr><td align="center">6</td><td align="center">SimpleMemobj::CPUSidePort</td><td align="left">void recvFunctional(PacketPtr pkt)</td></tr><tr><td align="center">7</td><td align="center">SimpleMemobj::CPUSidePort</td><td align="left">bool recvTimingReq(PacketPtr pkt)</td></tr><tr><td align="center">8</td><td align="center">SimpleMemobj::CPUSidePort</td><td align="left">void recvRespRetry()</td></tr><tr><td align="center">8</td><td align="center">SimpleMemobj::MemSidePort</td><td align="left">void sendPacket(PacketPtr pkt)</td></tr><tr><td align="center">9</td><td align="center">SimpleMemobj::MemSidePort</td><td align="left">bool recvTimingResp(PacketPtr pkt)</td></tr><tr><td align="center">9</td><td align="center">SimpleMemobj::MemSidePort</td><td align="left">void recvReqRetry()</td></tr><tr><td align="center">10</td><td align="center">SimpleMemobj::MemSidePort</td><td align="left">void recvRangeChange()</td></tr><tr><td align="center">11</td><td align="center">SimpleMemobj</td><td align="left">bool handleRequest(PacketPtr pkt)</td></tr><tr><td align="center">12</td><td align="center">SimpleMemobj</td><td align="left">bool handleResponse(PacketPtr pkt)</td></tr><tr><td align="center">13</td><td align="center">SimpleMemobj</td><td align="left">void handleFunctional(PacketPtr pkt)</td></tr><tr><td align="center">14</td><td align="center">SimpleMemobj</td><td align="left">AddrRangeList getAddrRanges() const</td></tr><tr><td align="center">15</td><td align="center">SimpleMemobj</td><td align="left">void sendRangeChange()</td></tr></tbody></table><p>在learning gem5的网站中，给出了这样一个函数之间的关系图：</p><p><img                       lazyload                     alt="image"                     data-src="http://learning.gem5.org/book/_images/memobj_api.png"                      alt="函数关系图"                ></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>主要分为以下步骤：</p><ul><li>将system.cpu的i-cache和d-cache的端口分别连接到MemoryObj的指令端口和数据端口；</li><li>将MemoryObj的内存端口连接到系统总线端。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">system.memobj = SimpleMemobj()</span><br><span class="line">...</span><br><span class="line">system.cpu.icache_port = system.memobj.inst_port</span><br><span class="line">system.cpu.dcache_port = system.memobj.data_port</span><br><span class="line">...</span><br><span class="line">system.memobj.mem_side = system.membus.cpu_side_ports</span><br></pre></td></tr></table></figure><h3 id="部件连接图"><a href="#部件连接图" class="headerlink" title="部件连接图"></a>部件连接图</h3><p>在m5out中的config.dot.pdf的结果如下：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-5/2.png"                      alt="连接图2"                ></p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>执行结果如下，可以看出程序仍然能够正常执行：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-5/3.png"                      alt="运行结果2"                ></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a class="link"   href="http://learning.gem5.org/book/presentation_notes/part2.html" >http://learning.gem5.org/book/presentation_notes/part2.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://learning.gem5.org/book/part2/helloobject.html" >http://learning.gem5.org/book/part2/helloobject.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://learning.gem5.org/book/part2/memoryobject.html" >http://learning.gem5.org/book/part2/memoryobject.html<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;参考learning gem5的part II部分进行gem5的学习。&lt;/p&gt;
&lt;p&gt;主要工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义实现了一个</summary>
      
    
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="gem5" scheme="https://iamywang.github.io/tags/gem5/"/>
    
    <category term="CPU" scheme="https://iamywang.github.io/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>gem5（4）——利用gem5自定义系统配置在SE模式下进行模拟</title>
    <link href="https://iamywang.github.io/2022/09/12/gem5-4/"/>
    <id>https://iamywang.github.io/2022/09/12/gem5-4/</id>
    <published>2022-09-12T12:12:00.000Z</published>
    <updated>2022-09-12T12:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>参考learning gem5的part I部分，对gem5的配置文件的编写进行学习。<br>在这次的配置中，主要涉及到内存、Cache的配置，与之前复现的那篇论文相比，没有实现TLB。<br>此外，我还发现learning gem5中的很多参数已经与最新版本的gem5有一定的区别，尽管bus.slave和bus.master等参数在新版本（v22）中仍然可用，但是我还是将他们替换成新版本（v22）推荐的cpu_side_ports和mem_side_ports。</p><h2 id="自定义配置并运行"><a href="#自定义配置并运行" class="headerlink" title="自定义配置并运行"></a>自定义配置并运行</h2><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>第一步，导入所需的依赖包以及初始化系统：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入gem5的objects</span></span><br><span class="line"><span class="keyword">import</span> m5</span><br><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化系统</span></span><br><span class="line">system = System()</span><br></pre></td></tr></table></figure><p>第二步，配置系统时钟频率和内存大小，我配置的时钟频率为1GHz，内存大小为2G：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置系统的时钟频率为1GHz</span></span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = <span class="string">&#x27;1GHz&#x27;</span></span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统的内存大小为2GB</span></span><br><span class="line">system.mem_mode = <span class="string">&#x27;timing&#x27;</span></span><br><span class="line">system.mem_ranges = [AddrRange(<span class="string">&#x27;2048MB&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>第三步，创建CPU、内存控制器、中断控制器等，并进行端口连接：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个CPU</span></span><br><span class="line">system.cpu = TimingSimpleCPU()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个内存控制器</span></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将CPU的端口连接到内存控制器</span></span><br><span class="line">system.cpu.icache_port = system.membus.cpu_side_ports</span><br><span class="line">system.cpu.dcache_port = system.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个中断控制器</span></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].pio = system.membus.mem_side_ports</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].int_requestor = system.membus.cpu_side_ports</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].int_responder = system.membus.mem_side_ports</span><br><span class="line"></span><br><span class="line">system.system_port = system.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个内存控制器</span></span><br><span class="line">system.mem_ctrl = MemCtrl()</span><br><span class="line">system.mem_ctrl.dram = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.dram.<span class="built_in">range</span> = system.mem_ranges[<span class="number">0</span>]</span><br><span class="line">system.mem_ctrl.port = system.membus.mem_side_ports</span><br></pre></td></tr></table></figure><p>第四步，创建进程并设置运行参数，我选择了gem5中自带的hello world程序进行测试：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个进程</span></span><br><span class="line">process = Process()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置进程的命令行参数</span></span><br><span class="line">process.cmd = [<span class="string">&#x27;/home/jammy/gem5/tests/test-progs/hello/bin/x86/linux/hello&#x27;</span>]</span><br><span class="line">system.workload = SEWorkload.init_compatible(<span class="string">&#x27;/home/jammy/gem5/tests/test-progs/hello/bin/x86/linux/hello&#x27;</span>)</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个根对象</span></span><br><span class="line">root = Root(full_system = <span class="literal">False</span>, system = system)</span><br></pre></td></tr></table></figure><p>第五步，初始化以及运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化gem5</span></span><br><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行gem5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Beginning simulation!&quot;</span>)</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印运行结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exiting @ tick &#123;&#125; because &#123;&#125;&#x27;</span></span><br><span class="line">        .<span class="built_in">format</span>(m5.curTick(), exit_event.getCause()))</span><br></pre></td></tr></table></figure><h3 id="配置结果"><a href="#配置结果" class="headerlink" title="配置结果"></a>配置结果</h3><p>输出的配置结果如下，可以看到一个简单的CPU与内存等的连接图：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-4/2.png"                      alt="配置1"                ></p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行结果如下，可以看出输出了Hello World：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-4/1.png"                      alt="运行结果1"                ></p><h2 id="添加Cache并运行"><a href="#添加Cache并运行" class="headerlink" title="添加Cache并运行"></a>添加Cache并运行</h2><h3 id="添加L1-Cache"><a href="#添加L1-Cache" class="headerlink" title="添加L1 Cache"></a>添加L1 Cache</h3><p>L1指令缓存类，实现了简单的参数以及与CPU连接的函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">L1ICache</span>(<span class="title class_ inherited__">L1Cache</span>):</span><br><span class="line">    size = <span class="string">&#x27;16kB&#x27;</span></span><br><span class="line">    assoc = <span class="number">2</span></span><br><span class="line">    tag_latency = <span class="number">2</span></span><br><span class="line">    data_latency = <span class="number">2</span></span><br><span class="line">    response_latency = <span class="number">2</span></span><br><span class="line">    mshrs = <span class="number">4</span></span><br><span class="line">    tgts_per_mshr = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connectCPU</span>(<span class="params">self, cpu</span>):</span><br><span class="line">        self.cpu_side = cpu.icache_port</span><br></pre></td></tr></table></figure><p>L1数据缓存类，实现了简单的参数以及与CPU连接的函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">L1DCache</span>(<span class="title class_ inherited__">L1Cache</span>):</span><br><span class="line">    size = <span class="string">&#x27;64kB&#x27;</span></span><br><span class="line">    assoc = <span class="number">2</span></span><br><span class="line">    tag_latency = <span class="number">2</span></span><br><span class="line">    data_latency = <span class="number">2</span></span><br><span class="line">    response_latency = <span class="number">2</span></span><br><span class="line">    mshrs = <span class="number">4</span></span><br><span class="line">    tgts_per_mshr = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connectCPU</span>(<span class="params">self, cpu</span>):</span><br><span class="line">        self.cpu_side = cpu.dcache_port</span><br></pre></td></tr></table></figure><p>创建L1 Cache并连接L2总线：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建L1Cache</span></span><br><span class="line">system.cpu.icache = L1ICache()</span><br><span class="line">system.cpu.dcache = L1DCache()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将CPU连接到L1</span></span><br><span class="line">system.cpu.icache.connectCPU(system.cpu)</span><br><span class="line">system.cpu.dcache.connectCPU(system.cpu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个L2总线</span></span><br><span class="line">system.l2bus = L2XBar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将L1与L2总线连接</span></span><br><span class="line">system.cpu.icache.connectBus(system.l2bus)</span><br><span class="line">system.cpu.dcache.connectBus(system.l2bus)</span><br></pre></td></tr></table></figure><h3 id="添加L2-Cache"><a href="#添加L2-Cache" class="headerlink" title="添加L2 Cache"></a>添加L2 Cache</h3><p>L2缓存类，只实现了简单的latency等参数，以及两个总线连接的函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">L2Cache</span>(<span class="title class_ inherited__">Cache</span>):</span><br><span class="line">    size = <span class="string">&#x27;256kB&#x27;</span></span><br><span class="line">    assoc = <span class="number">8</span></span><br><span class="line">    tag_latency = <span class="number">20</span></span><br><span class="line">    data_latency = <span class="number">20</span></span><br><span class="line">    response_latency = <span class="number">20</span></span><br><span class="line">    mshrs = <span class="number">20</span></span><br><span class="line">    tgts_per_mshr = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connectCPUSideBus</span>(<span class="params">self, bus</span>):</span><br><span class="line">        self.cpu_side = bus.mem_side_ports</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connectMemSideBus</span>(<span class="params">self, bus</span>):</span><br><span class="line">        self.mem_side = bus.cpu_side_ports</span><br></pre></td></tr></table></figure><p>创建L2 Cache并连接总线：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建L2 Cache</span></span><br><span class="line">system.l2cache = L2Cache()</span><br><span class="line">system.l2cache.connectCPUSideBus(system.l2bus)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个内存总线</span></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将L2 Cache与内存总线连接</span></span><br><span class="line">system.l2cache.connectMemSideBus(system.membus)</span><br></pre></td></tr></table></figure><h3 id="配置结果-1"><a href="#配置结果-1" class="headerlink" title="配置结果"></a>配置结果</h3><p>输出的配置结果如下，与前面的简单配置相比，更加复杂，不过逻辑还是很清晰：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-4/3.png"                      alt="配置2"                ></p><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行结果如下：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-4/4.png"                      alt="运行结果2"                ></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a class="link"   href="http://learning.gem5.org/book/part1/index.html" >http://learning.gem5.org/book/part1/index.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://learning.gem5.org/book/presentation_notes/part1.html" >http://learning.gem5.org/book/presentation_notes/part1.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://learning.gem5.org/book/part1/cache_config.html" >http://learning.gem5.org/book/part1/cache_config.html<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;参考learning gem5的part I部分，对gem5的配置文件的编写进行学习。&lt;br&gt;在这次的配置中，主要涉及到内存、Cache的配</summary>
      
    
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="gem5" scheme="https://iamywang.github.io/tags/gem5/"/>
    
    <category term="CPU" scheme="https://iamywang.github.io/tags/CPU/"/>
    
    <category term="Cache" scheme="https://iamywang.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>gem5（3）——gem5相关论文整理</title>
    <link href="https://iamywang.github.io/2022/09/08/gem5-3/"/>
    <id>https://iamywang.github.io/2022/09/08/gem5-3/</id>
    <published>2022-09-08T03:00:00.000Z</published>
    <updated>2022-09-08T03:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文列表"><a href="#论文列表" class="headerlink" title="论文列表"></a>论文列表</h2><table><thead><tr><th align="center">序号</th><th align="left">论文</th><th align="center">出处</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">DAGguise: Mitigating memory timing side channels</td><td align="center">ASPLOS 2022</td></tr><tr><td align="center">2</td><td align="left">Pinned loads: Taming speculative loads in secure processors</td><td align="center">ASPLOS 2022</td></tr><tr><td align="center">3</td><td align="left">Abusing Cache Line Dirty States to Leak Information in Commercial Processors</td><td align="center">HPCA 2022</td></tr><tr><td align="center">4</td><td align="left">unXpec: Breaking Undo-based Safe Speculation</td><td align="center">HPCA 2022</td></tr><tr><td align="center">5</td><td align="left">PS-ORAM: Efficient crash consistency support for oblivious RAM on NVM</td><td align="center">ISCA 2022</td></tr><tr><td align="center">6</td><td align="left">MOESI-prime: Preventing coherence-induced hammering in commodity workloads</td><td align="center">ISCA 2022</td></tr><tr><td align="center">7</td><td align="left">ProTRR: Principled yet Optimal In-DRAM Target Row Refresh</td><td align="center">S&amp;P 2022</td></tr><tr><td align="center">8</td><td align="left">SecSMT: Securing SMT processors against contention-based covert channels</td><td align="center">USENIX Security 2022</td></tr><tr><td align="center">9</td><td align="left">Composable Cachelets: Protecting Enclaves from Cache Side-Channel Attacks</td><td align="center">USENIX Security 2022</td></tr></tbody></table><h2 id="DAGguise-Mitigating-memory-timing-side-channels"><a href="#DAGguise-Mitigating-memory-timing-side-channels" class="headerlink" title="DAGguise: Mitigating memory timing side channels"></a>DAGguise: Mitigating memory timing side channels</h2><p>本文研究了内存时序旁路的缓解问题，攻击者利用DRAM控制器内的争夺来推断受害者的秘密。这类通道已经很实用，对共享内存环境中的安全计算构成了重要的挑战。</p><p>现有的最先进的内存定时侧信道缓解措施有几个关键的性能和安全限制。先前的方案需要繁琐的静态带宽划分，广泛的剖析阶段，或者根本无法防止利用细粒度的定时和银行信息的攻击。</p><p>作者提出了DAGguise，这是一种防御机制，可以完全防止内存时间侧信道，同时允许动态流量争用，以实现良好的性能。DAGguise利用一种新的抽象内存访问表示法，即有向无环请求图（简称DAG），来模拟经历争夺的内存访问模式。DAGguise根据公开的𝑟DAG塑造受害者的内存访问模式，通过轻量级的剖析阶段获得，完全消除了信息泄漏。</p><p>作者形式化验证了DAGguise的安全性，证明它保持了强大的安全保证。此外，通过允许动态流量竞争，DAGguise实现了相对于Fixed Service的12%的整体系统速度提升，Fixed Service是最先进的缓解机制，对于不需要保护的同地应用，其相对速度提升了20%。作者进一步宣称，DAGguise的原则可以被推广到保护其他类型的基于调度器的时序侧信道，例如那些针对片上网络或SMT内核的功能单元的侧信道。</p><h2 id="Pinned-loads-Taming-speculative-loads-in-secure-processors"><a href="#Pinned-loads-Taming-speculative-loads-in-secure-processors" class="headerlink" title="Pinned loads: Taming speculative loads in secure processors"></a>Pinned loads: Taming speculative loads in secure processors</h2><p>在投机执行的安全框架中，当一条指令不再容易受到流水线压制时，它就会达到其可见点（VP）。在一个潜在的泄漏指令达到其VP之前，它必须停滞，除非有一个防御方案，如隐形投机提供保护。不幸的是，无论是停顿还是保护前VP指令的执行，通常都有性能上的代价。</p><p>实现低开销安全执行的方法之一是开发技术，加速VP从旧指令向新指令的推进。在本文中，作者提出了一个这样的技术。作者发现，在没有可能违反内存一致性（MCVs）的情况下，加载VP的进展主要受到阻碍。因此，作者的技术被称为 “钉住负载”，试图使负载尽可能早地不受MCVs的影响，作者称之为在流水线上钉住负载的过程。其结果是加快了副总裁的进度，减少了防御方案的执行开销。</p><p>在本文中，作者描述了Pinned Loads所需要的硬件，以及两种可能的Pinned Loads设计，在硬件要求和性能之间有不同的权衡。作者的评估表明，Pinned Loads非常有效：用Pinned Loads扩展三种流行的防御方案，防止投机执行攻击，在SPEC17和SPLASH2&#x2F;PARSEC应用中的平均执行开销减少了约50%。例如，在SPEC17上，三种防御方案的执行开销从112.6%下降到51.3%，从35.8%下降到15.3%，以及从24.8%下降到13.2%。</p><h2 id="Abusing-Cache-Line-Dirty-States-to-Leak-Information-in-Commercial-Processors"><a href="#Abusing-Cache-Line-Dirty-States-to-Leak-Information-in-Commercial-Processors" class="headerlink" title="Abusing Cache Line Dirty States to Leak Information in Commercial Processors"></a>Abusing Cache Line Dirty States to Leak Information in Commercial Processors</h2><p>缓存已经被用来构建各种类型的隐蔽和侧面渠道来泄露信息。大多数隐蔽的高速缓存通道利用了高速缓存点击和高速缓存失误之间的时间差异。然而，作者引入了一个新的和更广泛的缓存隐蔽渠道攻击分类。Hit+Miss，Hit+Hit，以及Miss+Miss。作者强调，处于不同状态的缓存线的缓存缺失（或缓存命中）可能有更大的时间差异，这些可以被用作定时通道。基于这种分类，作者提出了一种新的稳定和隐蔽的Miss+Miss缓存通道。回写型高速缓存在现代处理器中被广泛部署。</p><p>本文详细介绍了一种方法，即替换延迟的差异可以用来构建基于时间的通道（称为WB通道）来泄露回写缓存中的信息。发送方对缓存行的任何修改都会将其设置为脏污状态，而接收方可以通过测量替换这个缓存集的延迟来观察到这一点。作者还演示了发送方如何利用缓存组中不同数量的脏缓存线来提高编码多比特的符号的传输带宽。在发送方和接收方之间没有共享内存的超线程设置中，商业系统中WB信道的峰值传输带宽可以在每个缓存集1300到4400kbps之间变化。</p><p>与大多数现有的总是针对特定内存地址的高速缓存通道相比，新的WB通道专注于高速缓存集和高速缓存行的状态，使得通道很难受到内核上其他进程的干扰，而且它们仍然可以在使用随机替换策略的高速缓存中工作。作者还从高速缓存负载的数量和高速缓存失误率的角度分析了WB通道的隐蔽性。作者讨论并评估了可能的防御措施。本文最后讨论了各种形式的侧面通道攻击。</p><h2 id="unXpec-Breaking-Undo-based-Safe-Speculation"><a href="#unXpec-Breaking-Undo-based-Safe-Speculation" class="headerlink" title="unXpec: Breaking Undo-based Safe Speculation"></a>unXpec: Breaking Undo-based Safe Speculation</h2><p>利用投机执行来泄密的投机执行攻击在工业界和学术界都引起了极大的关注。它们主要是利用由错误猜测和压制指令（即瞬时指令）留下的微架构状态的隐蔽或侧面通道。大多数此类攻击的目标是缓存状态。现有的基于缓存的防御系统对投机执行的攻击分为两类：shadow和undo。</p><p>大多数shadow防御系统对投机性指令的执行元数据进行缓冲，只有在投机性执行的指令被确定后才将其放入缓存。由于错误猜测是罕见的情况，undo防御系统允许猜测性指令修改缓存状态。一旦出现错误的猜测，它们会将缓存状态回滚到瞬时指令执行之前的状态。然而，shadow防御系统最近被投机性干扰攻击发现是不安全的。这就要求对undo防御系统进行深入的安全检查，以应对投机执行攻击。</p><p>在本文中，作者提出了unXpec作为对基于Undo的安全推测的第一种攻击。它利用了undo防御的回滚操作所表现出的秘密依赖的时间通道。具体来说，回滚过程需要使瞬时指令带入缓存的缓存行失效，并通过瞬时加载的数据从缓存中恢复被驱逐的缓存行。这就开辟了一个渠道，通过回滚时是否涉及很多无效和恢复的时间差异来编码秘密。作者进一步利用驱逐集来执行更多的恢复操作。这就产生了更长的回滚时间，从而产生了更大的依赖于秘密的时间差异。</p><p>作者在开源的CleanupSpec上展示了时间通道，这是一个有代表性的undo解决方案。一个单一的瞬时负载可以触发22个周期（没有驱逐集）和32个周期（有驱逐集）的秘密依赖的时间差异，这对于构建投机执行攻击的隐蔽通道来说是足够利用的。作者在gem5模拟器上运行unXpec并启用CleanupSpec。结果显示，unXpec可以以140Kbps的高速度泄露秘密，准确率超过90%。简单地强制执行恒定时间回滚以减轻unXpec的影响可能会引起超过70%的性能开销。</p><h2 id="PS-ORAM-Efficient-crash-consistency-support-for-oblivious-RAM-on-NVM"><a href="#PS-ORAM-Efficient-crash-consistency-support-for-oblivious-RAM-on-NVM" class="headerlink" title="PS-ORAM: Efficient crash consistency support for oblivious RAM on NVM"></a>PS-ORAM: Efficient crash consistency support for oblivious RAM on NVM</h2><p>Oblivious RAM（ORAM）是一种可证明的安全原件，用于防止内存总线上的访问模式泄漏。通过对数据块进行重新映射和访问冗余块，ORAM通过模糊化防止访问模式泄露。字节可寻址的非易失性存储器（NVM）被认为是主存储器的候选者，因为它具有更好的可扩展性，有竞争力的性能和持久的数据存储。虽然之前有很多工作集中在提高ORAM在传统的基于DRAM的内存系统上的性能，但当内存技术转向使用NVM时，为了安全、正确性和性能，需要确保一个高效的碰撞一致性的ORAM。对ORAM系统直接使用传统的基于软件的碰撞一致性支持不仅昂贵，而且不安全。</p><p>在这项工作中，作者研究了如何用一个基于NVM的内存系统来坚持ORAM的构建。为了在不破坏ORAM系统安全和影响性能的情况下支持碰撞一致性，作者提出了PS-ORAM。PS-ORAM包括一个新的ORAM控制器设计和一套支持崩溃一致性的ORAM访问协议。</p><p>作者对PS-ORAM与不支持崩溃一致性的系统进行了评估，非递归和递归的PS-ORAM只产生了4.29%和3.65%的额外性能开销。结果表明，PS-ORAM不仅以最小的性能和硬件开销支持有效的崩溃一致性，而且对NVM的寿命也是友好的。</p><h2 id="MOESI-prime-Preventing-coherence-induced-hammering-in-commodity-workloads"><a href="#MOESI-prime-Preventing-coherence-induced-hammering-in-commodity-workloads" class="headerlink" title="MOESI-prime: Preventing coherence-induced hammering in commodity workloads"></a>MOESI-prime: Preventing coherence-induced hammering in commodity workloads</h2><p>之前的工作表明，RowHammer攻击–通过频繁激活同一行来翻转DRAM中的比特–是可行的。广告商通常通过精心设计的指令序列来实施这些攻击，以绕过CPU缓存。然而，作者发现了一种新的翻转形式，作者称之为相干性诱导的翻转，由英特尔实施的缓存相干性非统一内存访问（ccNUMA）协议引起。作者表明，这种翻转发生在一个主要云提供商的生产硬件的商品基准中，这是第一次发现由非恶意代码产生的翻转。鉴于DRAM对比特翻转的敏感性上升，防止相干性引起的翻转以确保云的可靠性和安全性是最重要的。</p><p>因此，作者介绍了MOESI-prime，这是一种ccNUMA相干协议，可以缓解相干性引起的翻转，同时重新保持英特尔最先进的可扩展性。MOESI-prime表明，大多数DRAM的读和写触发这种翻转是不必要的。因此，通过在一致性协议中编码额外的信息，MOESI-prime可以省略这些读和写，防止在非恶意和恶意的工作负载中出现一致性引起的敲击。此外，通过省略不必要的读写，MOESI-prime对平均性能（在MESI和MOESI的±0.61%范围内）和平均DRAM功率（0.03%-0.22%的改进）的影响在评估的ccNUMA配置中可忽略不计。</p><h2 id="ProTRR-Principled-yet-Optimal-In-DRAM-Target-Row-Refresh"><a href="#ProTRR-Principled-yet-Optimal-In-DRAM-Target-Row-Refresh" class="headerlink" title="ProTRR: Principled yet Optimal In-DRAM Target Row Refresh"></a>ProTRR: Principled yet Optimal In-DRAM Target Row Refresh</h2><p>随着科技的发展，DRAM越来越容易受到Rowhammer攻击的影响。本文介绍了PROTRR，这是第一个原则性的DRAM内目标行刷新缓解措施，具有安全保证和低开销的界限。与需要改变内存控制器的现有建议不同，PROTRR的DRAM内性质使其能够无缝集成。然而，这意味着PROTRR必须尊重DRAM协议的同步性，这限制了在任何特定时间可以保护的DRAM行的数量。</p><p>为了克服这一挑战，PROTRR主动刷新未来最有可能观察到比特翻转的每一行。虽然这个策略可以捕捉到被攻击最多的行，但其他一些行可能仍然在雷达下飞。作者利用这一观察来构建FEINTING，这是一种新的行锤攻击，作者证明在这种情况下是最佳的。然后，作者对PROTRR进行配置，使其能够安全地应对FEINTING。为了实现这一点，PROTRR应该跟踪对每一行的访问，这在硬件上实现起来非常昂贵。相反，PROTRR使用一个新的频繁项目计数方案，利用FEINTING在可容忍的DRAM漏洞、计数器的数量和额外刷新的数量之间提供一个可证明的最佳而灵活的权衡。</p><p>作者使用PROTRR的ASIC实现和周期精确的模拟进行的广泛评估表明，PROTRR可以为当前和未来的DRAM技术提供原则性的保护，对性能、功耗和面积的影响可以忽略不计。PROTRR与DDR4和DDR5中新的刷新管理（RFM）扩展完全兼容。</p><h2 id="SecSMT-Securing-SMT-processors-against-contention-based-covert-channels"><a href="#SecSMT-Securing-SMT-processors-against-contention-based-covert-channels" class="headerlink" title="SecSMT: Securing SMT processors against contention-based covert channels"></a>SecSMT: Securing SMT processors against contention-based covert channels</h2><p>本文首次全面分析了高性能同步多线程（SMT）处理器中基于争用的安全漏洞。它的特点是描述了整个共享管道的争用情况，以及每个资源的潜在泄漏渠道。此外，它提出了一套统一的缓解&#x2F;隔离策略，在保留完整的、不安全的SMT实现的大部分性能的同时，极大地减少了这种泄漏。这些结果为考虑SMT执行及其性能优势奠定了基础，甚至对安全敏感的应用来说，它也是一个合理的选择。</p><h2 id="Composable-Cachelets-Protecting-Enclaves-from-Cache-Side-Channel-Attacks"><a href="#Composable-Cachelets-Protecting-Enclaves-from-Cache-Side-Channel-Attacks" class="headerlink" title="Composable Cachelets: Protecting Enclaves from Cache Side-Channel Attacks"></a>Composable Cachelets: Protecting Enclaves from Cache Side-Channel Attacks</h2><p>诸如英特尔SGX这样的隔离执行架构的安全性受到了最近出现的侧信道攻击的极大威胁。缓存侧信道攻击允许对手在不直接访问飞地内存的情况下泄露存储在飞地内部的秘密。在某些情况下，即使不知道受害者的应用代码或没有操作系统级别的权限，秘密也会被泄露。</p><p>作者提出了Composable Cachelets（CC）的概念，这是一种新的可扩展策略，用于动态划分最后一级缓存（LLC），将飞地与其他应用程序和相互之间完全隔离。CC支持缓存中的飞地隔离，能够在飞地被创建和销毁时动态地重新调整缓存容量。作者提出了一个缓存感知和飞地感知的操作语义，以帮助严格建立CC的安全属性，并且作者通过实验证明，CC在对性能和复杂性影响不大的情况下挫败了对缓存的旁路攻击。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;论文列表&quot;&gt;&lt;a href=&quot;#论文列表&quot; class=&quot;headerlink&quot; title=&quot;论文列表&quot;&gt;&lt;/a&gt;论文列表&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;序号&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;</summary>
      
    
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="论文" scheme="https://iamywang.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="体系结构" scheme="https://iamywang.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="gem5" scheme="https://iamywang.github.io/tags/gem5/"/>
    
  </entry>
  
  <entry>
    <title>中秋月饼</title>
    <link href="https://iamywang.github.io/2022/09/07/moon-cake-22/"/>
    <id>https://iamywang.github.io/2022/09/07/moon-cake-22/</id>
    <published>2022-09-07T12:00:00.000Z</published>
    <updated>2022-09-07T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年学校给的中秋月饼：</p><p>江城明月夜，何以为家，珞珈即家。</p><p><img                       lazyload                     alt="image"                     data-src="/images/moon-cake-22/1.jpg"                      alt="月饼1"                ></p><p><img                       lazyload                     alt="image"                     data-src="/images/moon-cake-22/2.jpg"                      alt="月饼2"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今年学校给的中秋月饼：&lt;/p&gt;
&lt;p&gt;江城明月夜，何以为家，珞珈即家。&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     alt=&quot;image&quot;
                     dat</summary>
      
    
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://iamywang.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="月饼" scheme="https://iamywang.github.io/tags/%E6%9C%88%E9%A5%BC/"/>
    
  </entry>
  
  <entry>
    <title>gem5（2）——利用gem5模拟Spectre攻击</title>
    <link href="https://iamywang.github.io/2022/09/06/gem5-2/"/>
    <id>https://iamywang.github.io/2022/09/06/gem5-2/</id>
    <published>2022-09-06T08:30:00.000Z</published>
    <updated>2023-04-11T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>从去年开始，一直在学习Meltdown攻击和Spectre攻击，包括攻击原理的学习、攻击的复现（在x86和ARM两种架构下复现）、利用符号执行（基于LLVM的KLEE）进行检测等。</p><p>Meltdown攻击是通过绕过CPU的权限检查机制，将内核态的数据读取到用户态，从而实现数据泄露。Spectre攻击是通过利用CPU的分支预测机制，让CPU错误预测执行，从而实现数据泄露。</p><p>这两种攻击都是通过利用CPU的特性来实现的，而gem5是一个CPU模拟器，并且提供了这两种攻击所利用到的乱序执行、分支预测特性以及Cache，因此理论上可以利用gem5来模拟这两种攻击。</p><h3 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h3><p>在查阅相关资料时，发现2021年的一篇文章[1]，利用gem5模拟了Spectre攻击，因此决定在学习gem5的过程中对这篇论文进行复现。</p><p>主要工作：</p><ol><li>复现论文”Reproducing Spectre Attack with gem5: How To Do It Right?”，尽管经过了一番努力，仍然没有配置成功；</li><li>利用gem5推荐的系统镜像运行并进行Spectre攻击的复现，这次系统引导成功，程序也可以运行，但是没有得到与论文中一样的结果；</li><li>利用X86架构的gem5模拟Spectre攻击，采用Spectre论文中的PoC。</li></ol><h2 id="2023-4-11-利用X86架构的gem5模拟器复现Spectre攻击"><a href="#2023-4-11-利用X86架构的gem5模拟器复现Spectre攻击" class="headerlink" title="(2023.4.11) 利用X86架构的gem5模拟器复现Spectre攻击"></a>(2023.4.11) 利用X86架构的gem5模拟器复现Spectre攻击</h2><p>PoC地址[6]：<a class="link"   href="https://spectreattack.com/spectre.pdf" >https://spectreattack.com/spectre.pdf<i class="fas fa-external-link-alt"></i></a></p><h3 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h3><p>CPU类型为乱序执行的DerivO3CPU，使用LTAGE分支预测器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build/X86/gem5.opt --debug-flags=O3PipeView --debug-start=369832000 --debug-file=trace.out \</span><br><span class="line">configs/example/se.py --caches --l2cache --cpu-type=DerivO3CPU --bp-type=LTAGE \</span><br><span class="line">--cmd=../spectre</span><br></pre></td></tr></table></figure><h3 id="SE模式下运行结果"><a href="#SE模式下运行结果" class="headerlink" title="SE模式下运行结果"></a>SE模式下运行结果</h3><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-2/6.png"                      alt="X86 SE模式下攻击成功"                ></p><h3 id="o3-pipeline"><a href="#o3-pipeline" class="headerlink" title="o3 pipeline"></a>o3 pipeline</h3><p>在gem5.opt添加参数–debug-flags&#x3D;O3PipeView –debug-start&#x3D;369832000 –debug-file&#x3D;trace.out，可以在m5out文件夹下生成trace.out文件，该文件包含了CPU的执行轨迹，可以利用o3-pipeview.py脚本将其转换为可视化的o3 pipeline。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./util/o3-pipeview.py -c 1000 -o pipeview.out --color m5out/trace.out</span><br></pre></td></tr></table></figure><p>在1GHz下，每个周期的Tick是1000（-c 1000），转化为可视化的o3 pipeline如下：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-2/7.png"                      alt="X86 o3 pipeline"                ></p><h2 id="论文环境搭建：在ARM架构下复现Spectre攻击"><a href="#论文环境搭建：在ARM架构下复现Spectre攻击" class="headerlink" title="论文环境搭建：在ARM架构下复现Spectre攻击"></a>论文环境搭建：在ARM架构下复现Spectre攻击</h2><p>本节的主要内容是复现论文”Reproducing Spectre Attack with gem5: How To Do It Right?”的环境配置。</p><h3 id="编译gem5"><a href="#编译gem5" class="headerlink" title="编译gem5"></a>编译gem5</h3><p>编译ARM架构的gem5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scons build/ARM/gem5.opt -j5</span><br></pre></td></tr></table></figure><p>编译m5term：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> util/term</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><h3 id="树莓派4B配置文件"><a href="#树莓派4B配置文件" class="headerlink" title="树莓派4B配置文件"></a>树莓派4B配置文件</h3><p>从[3]中克隆代码到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/pierreay/reproduce-spectre-gem5.git</span><br></pre></td></tr></table></figure><p>在gem5目录下有树莓派4和A72处理器核的配置文件：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-2/1.png"                      alt="配置文件列表"                ></p><h3 id="操作系统和内核"><a href="#操作系统和内核" class="headerlink" title="操作系统和内核"></a>操作系统和内核</h3><p>下载系统和内核镜像文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O - http://dist.gem5.org/dist/current/arm/disks/linaro-minimal-aarch64.img.bz2 | bunzip2 &gt; linaro-minimal-aarch64.img</span><br><span class="line">$ wget -O - http://dist.gem5.org/dist/current/arm/aarch-system-201901106.tar.bz2 | tar xjv</span><br></pre></td></tr></table></figure><p>解压缩后的文件目录为：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-2/2.png"                      alt="系统文件列表"                ></p><h3 id="创建工作镜像"><a href="#创建工作镜像" class="headerlink" title="创建工作镜像"></a>创建工作镜像</h3><p>接下来利用dd命令创建workload.img文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=workload.img count=200K</span><br></pre></td></tr></table></figure><p>创建一个回环设备以便将镜像文件作为块设备访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dev=$(sudo losetup -f)</span><br><span class="line">$ sudo losetup -fP workload.img</span><br></pre></td></tr></table></figure><p>创建分区表以及ext4文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;,&quot;</span> | sudo sfdisk <span class="variable">$dev</span></span><br><span class="line">$ sudo mkfs.ext4 <span class="variable">$&#123;dev&#125;</span>p1</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-2/3.png"                      alt="创建分区表"                ></p><p>最后，从回环设备中卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo losetup -d <span class="variable">$dev</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>这里如果直接按照[2]中执行，会遇到以下问题：</p><p><strong>（1）没有将gem5的config添加到python的搜索路径中，会报找不到common的错误：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#x27;common&#x27;</span><br></pre></td></tr></table></figure><p>因此，需要修改RPIv4.py文件，添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">&quot;/home/gem5/gem5/configs/&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）在gem5的commit中（5195c801156d1f9ff08d7ef4aceff2ff532c852），参数ArmITB和ArmDTB被统一换成了ArmTLB：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-arm, configs: Remove ArmITB/ArmDTB</span><br><span class="line">Removing ArmITB and ArmDTB makes sense as it implies a fixed 2 TLBs system;</span><br><span class="line">by using the generic ArmTLB class we open up to a more generic configuration</span><br></pre></td></tr></table></figure><p>因此，修改ARMv8A_Cortex_A72.py文件，将ArmITB和ArmDTB替换成ArmTLB：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ARM_A72_TLB_L1D</span>(<span class="title class_ inherited__">ArmTLB</span>):</span><br><span class="line">    entry_type=<span class="string">&quot;data&quot;</span></span><br><span class="line">    size = <span class="number">48</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARM_A72_TLB_L1I</span>(<span class="title class_ inherited__">ArmTLB</span>):</span><br><span class="line">    entry_type=<span class="string">&quot;instruction&quot;</span></span><br><span class="line">    size = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARM_A72_Cluster</span>(<span class="title class_ inherited__">SubSystem</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connectDirect</span>(<span class="params">self, bus</span>):</span><br><span class="line">        <span class="keyword">for</span> cpu <span class="keyword">in</span> self.cpus:</span><br><span class="line">            cpu.mmu.dtb_walker.port = bus.slave</span><br><span class="line">            cpu.mmu.itb_walker.port = bus.slave</span><br><span class="line">            cpu.dcache_port = bus.slave</span><br><span class="line">            cpu.icache_port = bus.slave</span><br></pre></td></tr></table></figure><p><strong>（3）在gem5的commit中（6ecf110b06d7333aae13bcc16216cc127fdda7f0），flags_addr被移除：</strong></p><p>同时，参考configs&#x2F;example&#x2F;arm&#x2F;devices.py文件，将RPIv4.py中的对应代码去掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system.flags_addr = system.realview.realview_io.pio_addr + 0x30</span></span><br></pre></td></tr></table></figure><p><strong>（4）在gem5的commit中（5f95d7a89a56513876a7bb5dd8055d6b1d080c8b），IntrControl被移除：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpu: IntrControl, clear all and check helpers</span><br><span class="line">This patch extends the IntrControl to provided additional member functions for</span><br><span class="line">(1) clearing all pending interrupts in a PE and</span><br><span class="line">(2) checking for any pending interrupt in a PE.</span><br><span class="line">These are intended to be used from interrupt management related peripherals.</span><br></pre></td></tr></table></figure><p>因此，直接将RPIv4.py中的以下代码注释掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system.intrctrl = IntrControl()</span></span><br></pre></td></tr></table></figure><p><strong>（5）slave和master的接口变化：</strong></p><p>修改RPIv4.py文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wire up the system port to the previously created memory bus (gem5</span></span><br><span class="line"><span class="comment"># uses it to load the kernel and to perform debug accesses).</span></span><br><span class="line">self.system_port = self.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect the two IO bridges to the IO bus and the system bus.</span></span><br><span class="line">system.iobridge.iobus.mem_side_port = system.iobus.cpu_side_ports</span><br><span class="line">system.iobridge.iobus.cpu_side_port = system.membus.mem_side_ports</span><br><span class="line">system.iobridge.membus.mem_side_port = system.membus.cpu_side_ports</span><br><span class="line">system.iobridge.membus.cpu_side_port = system.iobus.mem_side_ports</span><br></pre></td></tr></table></figure><p>修改A72.py文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connectCacheL2</span>(<span class="params">self, bus</span>):</span><br><span class="line">    self.l2.mem_side = bus.cpu_side_ports</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connectDirect</span>(<span class="params">self, bus</span>):</span><br><span class="line">    <span class="keyword">for</span> cpu <span class="keyword">in</span> self.cpus:</span><br><span class="line">        cpu.mmu.itb_walker.port = bus.cpu_side_ports</span><br><span class="line">        cpu.mmu.dtb_walker.port = bus.cpu_side_ports</span><br><span class="line">        cpu.dcache_port = bus.cpu_side_ports</span><br><span class="line">        cpu.icache_port = bus.cpu_side_ports</span><br></pre></td></tr></table></figure><h3 id="启动系统"><a href="#启动系统" class="headerlink" title="启动系统"></a>启动系统</h3><p>首先，配置M5_PATH环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> M5_PATH=<span class="variable">$PWD</span>/img/</span><br></pre></td></tr></table></figure><p>接着，引导系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ build/ARM/gem5.opt -q -d 01boot \</span><br><span class="line">    ../reproduce-spectre-gem5/gem5/RPIv4.py -v --num-cores=4 --fs \</span><br><span class="line">    --fs-kernel=./img/binaries/vmlinux.arm64 \</span><br><span class="line">    --fs-disk-image=./img/linaro-minimal-aarch64.img \</span><br><span class="line">    --fs-workload-image=./img/workload.img</span><br></pre></td></tr></table></figure><p>引导过程如下：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-2/4.png"                      alt="引导过程"                ></p><p>然后，在另一个终端连接到m5term：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ util/term/m5term localhost 3456</span><br></pre></td></tr></table></figure><p>但是这一步可能是因为版本的问题失败了。尽管终端的输出显示已经开始模拟，连接m5term也有输出和提示，但是没有拿到ARM模拟器的shell，也没有引导成功的说明。</p><h2 id="gem5官方推荐ARM架构fs环境搭建"><a href="#gem5官方推荐ARM架构fs环境搭建" class="headerlink" title="gem5官方推荐ARM架构fs环境搭建"></a>gem5官方推荐ARM架构fs环境搭建</h2><h3 id="下载系统和内核"><a href="#下载系统和内核" class="headerlink" title="下载系统和内核"></a>下载系统和内核</h3><p>下载Linux系统和内核镜像文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O - http://dist.gem5.org/dist/v22-0/arm/aarch-system-20220707.tar.bz2 | tar xjv</span><br><span class="line">$ wget -O - http://dist.gem5.org/dist/v22-0/arm/disks/ubuntu-18.04-arm64-docker.img.bz2 | bunzip2 &gt; ubuntu-18.04-arm64-docker.img</span><br></pre></td></tr></table></figure><h3 id="引导系统"><a href="#引导系统" class="headerlink" title="引导系统"></a>引导系统</h3><p>引导系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ build/ARM/gem5.opt -q ./configs/example/fs.py --num-cpu=4 \ </span><br><span class="line">    --kernel=./ubuntu-1804/binaries/vmlinux.arm64 \</span><br><span class="line">    --disk-image=./ubuntu-1804/ubuntu-18.04-arm64-docker.img</span><br></pre></td></tr></table></figure><p>连接m5term：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ util/term/m5term localhost 3456</span><br></pre></td></tr></table></figure><p>引导成功的截图如下：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-2/5.png"                      alt="引导成功"                ></p><h3 id="挂载镜像"><a href="#挂载镜像" class="headerlink" title="挂载镜像"></a>挂载镜像</h3><p>挂载disk镜像并写入攻击程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p disk</span><br><span class="line">$ util/gem5img.py mount ~/ubuntu-1804/ubuntu-18.04-arm64-docker.img ./disk</span><br><span class="line">$ sudo <span class="built_in">cp</span> -r ~/reproduce-spectre-gem5/spectre ./root/</span><br></pre></td></tr></table></figure><h3 id="执行Spectre攻击"><a href="#执行Spectre攻击" class="headerlink" title="执行Spectre攻击"></a>执行Spectre攻击</h3><p>执行攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> spectre</span><br><span class="line">$ ./spectre -m 10 -l 100 -t 999</span><br></pre></td></tr></table></figure><p>但是没有得到预期的结果，攻击失败，猜测应该是环境与论文中的不一致导致的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>Ayoub, P., &amp; Maurice, C. (2021, April). Reproducing spectre attack with gem5: How to do it right?. In Proceedings of the 14th European Workshop on Systems Security (pp. 15-20).</li><li><a class="link"   href="https://pierreay.github.io/reproduce-spectre-gem5/" >https://pierreay.github.io/reproduce-spectre-gem5/<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/pierreay/reproduce-spectre-gem5" >https://github.com/pierreay/reproduce-spectre-gem5<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/gem5/gem5" >https://github.com/gem5/gem5<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.gem5.org/documentation/general_docs/fullsystem/guest_binaries" >https://www.gem5.org/documentation/general_docs/fullsystem/guest_binaries<i class="fas fa-external-link-alt"></i></a></li><li>Kocher, P., Horn, J., Fogh, A., Genkin, D., Gruss, D., Haas, W., … &amp; Yarom, Y. (2019, May). Spectre Attacks: Exploiting Speculative Execution. In 2019 IEEE Symposium on Security and Privacy (SP) (pp. 1-19). IEEE.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;从去年</summary>
      
    
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="gem5" scheme="https://iamywang.github.io/tags/gem5/"/>
    
    <category term="Spectre攻击" scheme="https://iamywang.github.io/tags/Spectre%E6%94%BB%E5%87%BB/"/>
    
    <category term="CPU安全" scheme="https://iamywang.github.io/tags/CPU%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>gem5（1）——环境搭建</title>
    <link href="https://iamywang.github.io/2022/09/05/gem5-1/"/>
    <id>https://iamywang.github.io/2022/09/05/gem5-1/</id>
    <published>2022-09-05T10:20:00.000Z</published>
    <updated>2022-09-05T10:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前曾经接触过gem5，不过只是停留在利用gem5完成一些简单的工作，并没有对gem5的源代码以及具体的配置做深入的学习。<br>本次的目标是打算对gem5的配置文件（即具体的System配置）以及源代码（即gem5每个功能的实现）有深入的学习和理解。</p><h2 id="虚拟机环境"><a href="#虚拟机环境" class="headerlink" title="虚拟机环境"></a>虚拟机环境</h2><p>我使用的是最新的Ubuntu 22.04：</p><table><thead><tr><th align="center">环境</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">虚拟机</td><td align="center">VMware Workstation 16.2.4</td></tr><tr><td align="center">系统</td><td align="center">Ubuntu Server 22.04.1 LTS</td></tr><tr><td align="center">CPU</td><td align="center">Intel(R) Core(TM) i5-9400 CPU @ 2.90GHz</td></tr><tr><td align="center">内存</td><td align="center">8GB</td></tr></tbody></table><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>首先，更换apt源为阿里云源，以加快下载速度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">$ sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>插入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>然后，更新apt源并安装所需的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install build-essential git m4 scons zlib1g zlib1g-dev \</span><br><span class="line">    libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \</span><br><span class="line">    python3-dev python-is-python3 libboost-all-dev pkg-config</span><br></pre></td></tr></table></figure><h2 id="编译gem5"><a href="#编译gem5" class="headerlink" title="编译gem5"></a>编译gem5</h2><p>从gem5的官方仓库克隆源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://gem5.googlesource.com/public/gem5</span><br></pre></td></tr></table></figure><p>利用SCons命令编译gem5，以编译x86架构的处理器为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gem5</span><br><span class="line">$ scons build/X86/gem5.opt -j4</span><br></pre></td></tr></table></figure><p>编译完成后的输出如下图所示：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-1/1.png"                      alt="gem5编译结果"                ></p><p>在<code>build/X86</code>目录下生成的<code>gem5.opt</code>文件，即为编译好的gem5可执行文件。</p><p>此外，除了支持<code>x86</code>架构，gem5还支持<code>ARM</code>、<code>MIPS</code>、<code>RISC-V</code>等架构，具体的参数为修改<code>build/ISA</code>中的<code>ISA</code>为对应的架构名即可。<br>gem5的后缀名代表的含义是编译时的优化参数，除了<code>opt</code>外，还有<code>debug</code>、<code>fast</code>，具体的含义可以参考官方文档。</p><h2 id="运行gem5"><a href="#运行gem5" class="headerlink" title="运行gem5"></a>运行gem5</h2><p>以gem5自带的测试程序为例，运行gem5的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ build/X86/gem5.opt \</span><br><span class="line">    configs/example/se.py \</span><br><span class="line">    --cpu-type=TimingSimpleCPU \</span><br><span class="line">    --caches \</span><br><span class="line">    --cmd=tests/test-progs/hello/bin/x86/linux/hello</span><br></pre></td></tr></table></figure><p>其中，<code>--cpu-type</code>参数指定了使用的CPU类型，<code>--caches</code>参数指定了使用的缓存类型，<code>--cmd</code>参数指定了运行的程序。</p><p>运行结果如下图所示：</p><p><img                       lazyload                     alt="image"                     data-src="/images/gem5-1/2.png"                      alt="gem5运行结果"                ></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a class="link"   href="https://www.gem5.org/documentation/general_docs/building" >https://www.gem5.org/documentation/general_docs/building<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;之前曾经接触过gem5，不过只是停留在利用gem5完成一些简单的工作，并没有对gem5的源代码以及具体的配置做深入的学习。&lt;br&gt;本次的目标</summary>
      
    
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="体系结构" scheme="https://iamywang.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="gem5" scheme="https://iamywang.github.io/tags/gem5/"/>
    
  </entry>
  
</feed>
